alias si="sh -i"
alias pgrep="ps aux | grep"
alias gosh="rlwrap -b '(){}[],#\";| ' gosh -l ~/lib/scheme/init.scm"
alias el="emacs -Q --script"
alias sshX="ssh -c blowfish -2 -C -Y"
alias h=history
alias w=which
alias vm=VBoxManage
alias rh=runhaskell
alias cd=cdls
alias ll='ls -alF'
alias la='ls -A'
alias l='ls'
alias pd='pushd'
alias po='popd'
alias ds='dirs -v'
alias j="jobs"
alias i="ipython3"
alias g="git"
#alias r='echo $?'
#alias rm="rm -i"
alias cp="cp -i"
alias mv="mv -i"
alias sl='ls -CF'
alias gd='dirs -v; echo -n "select number: "; read newdir; pushd +"$newdir"'
alias r='ruby -e'
alias p="perl $PERL_OPTION -E"
alias pn="perl $PERL_OPTION -nalE"
alias pp="perl $PERL_OPTION -palE"
alias pp='perl -plE'
alias pn='perl -nlE'
alias f='fab -f ~/fabfile'
alias c="cdr"
alias sudo="sudo "  # sudo時にアリアス有効
alias v="view"
alias m=mysql_execute
alias tree="pwd;find . | sort | sed '1d;s/^\.//;s/\/\([^/]*\)$/|--\1/;s/\/[^/|]*/|  /g'"
alias clang++="clang++ -std=c++11"
alias clg="clang `gauche-config -I` `gauche-config -L` `gauche-config -l`"
alias eo=__emacs_oneliner
#alias ee="emacsclient -e"
alias ea='emacsclient -nw -a ""'
alias en='emacsclient -n'
alias e='emacsclient -t'
alias d='emacsclient -t .'
alias ..=".."
alias my=mysql_execute
# alias s=snippets
alias ce=_complie_and_run_in_c
alias he=_run_in_haskell
alias cpe=_complie_and_run_in_cpp
alias grep='egrep -i'
alias hist='fc -l'
# alias go="rlwrap -b '(){}[],#\";| ' gosh -l ~/lib/scheme/init.scm"

goshe(){
    local main=$1; shift;
    gosh -l ~/lib/scheme/init.scm -e "(--> $main (if (not (undefined? it)) (print it)))" "$@" -Eexit
}

# function
fg255(){
    perl -E 'print qq/\x1b[38;5;${_}mC$_ / for 0..255; say'
}

bg255(){
    perl -E 'print qq/\x1b[38;5;${_}mC$_ / for 0..255; say'
}

les(){
    if [ $# -eq 0 ]; then
        local file=/dev/stdin
    else
        local file=$1; shift;
    fi
    pygmentize -O style=monokai -f console256 -g "$file" | /usr/bin/less -R $@
}
alias c='pygmentize -O style=monokai -f console256 -g'


ff(){
    if [ $# -eq 1 ]; then
        find . -type f -print0 | xargs -0 grep -n $1
    elif [ $# -eq 2 ]; then
        find . -type f -print0 -name "*$2*" | xargs -0 grep -n $1
    fi
}


runjava() {
    javac $1.java
    java $1
}

ne() {
    node -e "
function P(msg){console.log(msg)};
var _ = require('underscore');
var jsdom = require('jsdom');
var window = jsdom.jsdom().defaultView
var \$ = require('jquery')(window);
$1;
"
}

py() {
    python -c "
from os.path import isdir, exists, join, basename
from os import environ, makedirs
from re import match, search
from sys import exit
from shutil import copy, rmtree, move
from argparse import ArgumentParser
def P(msg):
    print(msg)
$1
"
}

oneliner_gosh(){
    local Fflag="\n"
    local nflag=false
    local lflag=false  # TODO
    local pflag=false
    local Lflag=""
    # -0 -0777 -0
    local zeroflag=false
    local dflag=false  # debug
    local iflag=false  # TODO

    # TODO: -x -f -d オプションによるファイルパス識別
    while getopts lnpdF:L: OPT; do
	    case $OPT in
            d) dflag=true
               ;;
	        n) nflag=true
	           ;;
            p) pflag=true
	           ;;
            F) Fflag=$OPTARG
               ;;
	    esac
    done
    shift $((OPTIND - 1))

    if [ $# -eq 0 ]; then
        gosh -l ~/lib/scheme/init.scm
        return;
    fi
    
    # TODO: split by regexp
    local F=$(cat <<EOS
(define F (string-split line "$Fflag"))
EOS
)
    local tmpfile=`mktemp`
    local code=$1; shift;
    # if $nflag; then
    #     code="(port-for-each (lambda (line) $F (--> line $code)) read-line)"
    if $pflag; then
        code="(port-for-each (lambda (line) $F (--> line $code (print it))) read-line)"
    fi

    # TODO: BEGIN/END block
    # (BEGIN body)として、(set! block (lambda () body)) として展開させればよさそう？
    # zsh >!直す
    cat <<EOF >> $tmpfile
(use util.match)
(define (main args)
  (let1 ret
     (match args
        [() 1]
        [(_)  $code]
        ; かつ -p or -n
        [(_ . filepath-list)
         (dolist (filepath filepath-list)
                 (with-input-from-file filepath
                   (lambda () (let loop ((line (read-line))) $code
                                (if (not (eof-object? line))
                                    (loop (read-line)))))))
                   ])
   
   (if (not (undefined? ret)) (print ret)))
  0)
EOF

    if [ -n "$code" ]; then
        if $dflag; then
            cat $tmpfile
        else
            gosh -l ~/lib/scheme/init.scm $tmpfile $@
        fi
    else
        gosh -l ~/lib/scheme/init.scm  -e "" -E exit
    fi

    rm $tmpfile
}
alias s=oneliner_gosh
alias ee="emacs --batch --execute '(message $code)'"
alias ce=_complie_and_run_in_c
