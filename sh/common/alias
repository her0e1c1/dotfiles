# linux don't have -r option
# alias tac="tail -r"
alias si="sh -i"
alias pgrep="ps aux | grep"
alias gosh="rlwrap -b '(){}[],#\";| ' gosh -l ~/lib/scheme/init.scm"
alias el="emacs -Q --script"
alias sshX="ssh -c blowfish -2 -C -Y"
alias h=history
alias w=which
alias vm=VBoxManage
alias rh=runhaskell
alias cd=cdls
alias ll='ls -alF'
alias la='ls -A'
alias l='ls'
alias pd='pushd'
alias po='popd'
alias ds='dirs -v'
alias j="jobs"
alias i="ipython3"
alias g="git"
#alias r='echo $?'
#alias rm="rm -i"
alias cp="cp -i"
alias mv="mv -i"
alias sl='ls -CF'
alias gd='dirs -v; echo -n "select number: "; read newdir; pushd +"$newdir"'
alias r='ruby -e'
alias p="perl $PERL_OPTION -E"
alias pn="perl $PERL_OPTION -nalE"
alias pp="perl $PERL_OPTION -palE"
alias pp='perl -plE'
alias pn='perl -nlE'
alias f='fab -f ~/fabfile'
alias c="cdr"
alias sudo="sudo "  # sudo時にアリアス有効
alias v="view"
alias m=mysql_execute
alias tree="pwd;find . | sort | sed '1d;s/^\.//;s/\/\([^/]*\)$/|--\1/;s/\/[^/|]*/|  /g'"
alias clang++="clang++ -std=c++11"
# alias clg="clang `gauche-config -I` `gauche-config -L` `gauche-config -l`"
alias eo=__emacs_oneliner
#alias ee="emacsclient -e"
alias ea='emacsclient -nw -a ""'
alias en='emacsclient -n'
alias e='emacsclient -t'
alias d='emacsclient -t .'
alias ..=".."
alias my=mysql_execute
# alias s=snippets
alias ce=_complie_and_run_in_c
alias cpe=_complie_and_run_in_cpp
alias grep='egrep -i'
alias hist='fc -l'
# alias go="rlwrap -b '(){}[],#\";| ' gosh -l ~/lib/scheme/init.scm"

goshe(){
    local main=$1; shift;
    gosh -l ~/lib/scheme/init.scm -e "(--> $main (if (not (undefined? it)) (print it)))" "$@" -Eexit
}

# function
fg255(){
    perl -E 'print qq/\x1b[38;5;${_}mC$_ / for 0..255; say'
}

bg255(){
    perl -E 'print qq/\x1b[38;5;${_}mC$_ / for 0..255; say'
}

les(){
    if [ $# -eq 0 ]; then
        local file=/dev/stdin
    else
        local file=$1; shift;
    fi
    pygmentize -O style=monokai -f console256 -g "$file" | /usr/bin/less -R $@
}
alias c='pygmentize -O style=monokai -f console256 -g'


ff(){
    if [ $# -eq 1 ]; then
        find . -type f -print0 | xargs -0 grep -n $1
    elif [ $# -eq 2 ]; then
        find . -type f -print0 -name "*$2*" | xargs -0 grep -n $1
    fi
}


runjava() {
    javac $1.java
    java $1
}

ne() {
    local main=$1; shift;
    node -e "
function P(msg){console.log(msg)};
var _ = require('underscore');
var jsdom = require('jsdom');
var window = jsdom.jsdom().defaultView
var \$ = require('jquery')(window);
var JD = require('jquery-deferred');
$main
" $@
}

py() {
    local main=$1; shift;
    python -c "
from os.path import isdir, exists, join, basename
from os import environ, makedirs
from re import match, search, X, split
import re
import sys
import itertools
import functools
from sys import exit, argv
from shutil import copy, rmtree, move
from argparse import ArgumentParser
import time
def P(msg):
    print(msg)
$main
" $@
}

alias s="\gosh -l ~/lib/scheme/init.scm ~/github/onelinerForGauche/main.scm"
alias ss="\gosh ~/github/onelinerForGauche/main.scm"
alias sl="\gosh -l ~/lib/scheme/init.scm -e '' -Eexit"
# alias ee="emacs --batch --execute '(message $code)'"
alias ce=_complie_and_run_in_c


ee() {
    emacs --batch --execute "
(progn
 (require 'cl)
 (require 'comint)
  (defmacro let1 (var expr &rest body)
    \`(let ((,var ,expr))
        ,@body))
 ; caskをパスを指定してロードすれば、
 ; 合わせて以下のモジュールをロードしたことになる
 ; '(s dash f commander git epl shut-up cl-lib package-build)
 (require 'cask \"~/.cask/cask.el\")
 (print (progn $1))
)
"
}

java_oneliner() {
    source=$(cat <<EOF
import java.util.*;
public class Oneliner {
    static void P(Object o) { System.out.println(o); }
    public static void main (String[] args) {
        $1
    }
}
EOF
)
    echo $source > Oneliner.java
    javac Oneliner.java
    java Oneliner
    rm Oneliner.java
    rm Oneliner.class
}
alias je=java_oneliner

haskell_oneliner() {
    local main=$1; shift
    source=$(cat <<EOF
import Control.Applicative
import Control.Monad
import Data.List
import Data.Array
import System.Directory
import System.Environment
main = print ($main)
EOF
)
   tfile=`mktemp`
   echo "$source" >> $tfile
   runhaskell $tfile "$@"
   \rm $tfile
}
alias he=haskell_oneliner

emacs_daemon() {
    if [ -n "`emacs -Q --batch --execute "(progn (require 'server) (princ (server-running-p)))"| grep nil`" ]; then
        emacs --daemon
    else
        echo "emacs is already launched"
    fi
}

start() {
    emacs_daemon
    tmux new \; splitw -h \; neww
};

update_ansible() {
    local old=`pwd`
    local cwd=/vagrant/kickstart
    local user=`whoami`

    while getopts u: OPT; do
        case $OPT in
        u) user=$OPTARG
        ;;
        esac
    done

    \cd $cwd
    git pull
    ansible-playbook -c local -i "$user," site.yml
    \cd $old
}
alias up=update_ansible

docker_backup() {
    local data=$1
    local dir=$2
    docker run --rm --volumes-from "$data" -v $(pwd):/backup busybox tar cvf /backup/backup.tar "$dir"
}

docker_restore() {
    local name=$1
    local backup=$2
    docker volume create --name "$name"
    docker run --rm -v "$name:/volume" -v `pwd`:/backup centos tar xvf "/backup/$backup" -C /
}

docker_volume() {
    local name=$1
    docker run --rm -itv "$name:/volume" busybox sh
}
